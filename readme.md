# Fenix — пример распределённой системы с асинхронным межсервисным взаимодействием

Как следует из описания — это пример распределённой системы, сервисы которой взаимодействуют между собой по средствам асинхронных сообщений. Выбранной предметной областью является [кредитование крупных корпоративных клиентов](TODO: статья с описанием предметной области). Основной решаемой задачей — [автоматизация согласование лимита группы компаний](TODO: описание функциональных требований и целевого решения).

Выбор домена не случаен. Некоторое время назад я участвовал в разработке аналогичного продукта, но в силу ряда причин не смог довести его до первой полноценной версии. Одной из таких причин была как раз сложность домена. Агрегат (класс корня агрегата и вложенные сущности и объекты-значения) продуктового лимита вылился в несколько десятков тысяч строк, если учитывать модульные тесты. Да, в нормальной ситуации — это слишком много, и нужно задуматься о разделении агрегата на более мелкие агрегаты, но в данном случае это было данностью предметной области. Я не ставлю перед собой целью повторить тот продукт и заложить в данный пример всю экспертизу об инвестиционном кредитовании, которую я получил. Моя цель в ином. Я хочу отработать архитектуру распределённой системы, сервисы которой взаимодействуют между собой преимущественно по средствам отправки и обработки асинхронных сообщений. Очень сильно упрощённая версия предметной области корпоративного кредитования — лишь декорации.

Выбор архитектурных решений продиктован архитектурными требованиями (их часто называют «нефункциональными»), предъявленных системе со стороны заказчиков. Более подробно требования я разбираю в статье [Архитектурные требования](TODO: Написать статью, здесь дать ссылку), а сами решения буду фиксировать в отдельных [статьях](TODO: ссылка на раздел «Архитектурные решения»).

Помимо непосредственно архитектуры и её реализации в коде в данном проекте я хочу отработать подход разработки распределённой системы через тестирование (TDD). TDD ≠ модульные тесты. Да, большинство разработчиков знакомятся с этим подходом при написании модульных тестов (unit tests), но сам подход универсален и может быть применён и для более крупных кусков кода. Например, отдельный сервис, его контроллер или даже всей системы целиком. Продуктом являются сквозные (end-to-end) и интеграционные (integration) тесты. То, что часто называют авто-тестами, подразумевая, что это не модульные тесты, то есть более сложные в разработке и запуске, так как связаны с инфраструктурой. Вот только чаще всего авто-тесты пишут после написания кода продукта и пишут их тестировщики, чтобы защититься от регрессионных ошибок. Я же хочу вначале писать такие тесты, а потом добиваться их успешного выполнения по средствам реализации кода продукта. Тесты должны направлять разработку продукта.

Проблема тестирования распределённой системы связана, прежде всего, с её природой: она состоит из некоторого (иногда весьма большого) количества самостоятельных приложений, взаимодействующих между собой по сети. Во-первых, такую систему необходимо уметь развернуть. Я исхожу из того, что на дворе двадцатые годы двадцать первого века, и золотым стандартом для новых систем является развёртывание с помощью оркестратора контейнеров. Во-вторых, если мы хотим иметь возможность писать тесты для такой системы достаточно просто и дёшево, нужно иметь возможность развернуть систему на локальной машине разработчика. Если с первым пунктом всё уже достаточно очевидно и проработано, то готового решения для второго я не мог найти достаточно долго. Оказалось, что уже есть продукты, решающие данную проблему, и их даже несколько: [Draft](https://github.com/Azure/draft), [Garden](https://garden.io), [Skaffold](https://skaffold.dev), [Tilt](https://tilt.dev). Для себя я [выбрал Skaffold](TODO: написать статью о выборе).

